[["index.html", "Single Cell Multi-Omics Data Analysis Chapter 1 Preface", " Single Cell Multi-Omics Data Analysis Yuting Liu 2021-06-06 Chapter 1 Preface This book is a collect for pre-processing and visualizing scripts for single cell multi-omics data. The data is down-sampled from a real dataset. "],["process-analysis.html", "Process Analysis", " Process Analysis "],["intro.html", "Chapter 2 Seurat Pre-process 2.1 Load count matrix from CellRanger 2.2 Cell-level filtering 2.3 Merge individuals 2.4 Normalize, scale, find variable genes and dimension reduciton", " Chapter 2 Seurat Pre-process 2.1 Load count matrix from CellRanger for one experiment pre &lt;- Read10X(data.dir = &#39;cellranger-res/Pre-B/outs/filtered_feature_bc_matrix/&#39;) pre &lt;- CreateSeuratObject(counts = pre, project = &#39;11002C&#39;, min.cells = 3) for multiple experiments # step1 list sample directories ---------------------------------------------- dir.ls &lt;- list.dirs(path = &#39;cellranger-count/&#39;, full.names = T, recursive = F) dir.ls &lt;- dir.ls[c(2:5)] dir.ls %&lt;&gt;% map( ~ paste0(.x, &quot;/outs/filtered_feature_bc_matrix&quot;)) names(dir.ls) &lt;- c(&#39;68A&#39;, &#39;68B&#39;, &#39;84B&#39;, &#39;84C&#39;) # step2 check whether dir exist ------------------------------------------- dir.ls %&gt;% map( ~ dir.exists(.x)) # step3 create seurat per samples ----------------------------------------- obj.ls &lt;- dir.ls %&gt;% map( ~ Read10X(.x)) %&gt;% map( ~ CreateSeuratObject(.x, min.cells = 3)) 2.1.1 Quality control by visualization V1_Seurat_QC-CellLevelFiltering.R 2.2 Cell-level filtering # filtering by nCount and nFeatures per individual filterCell &lt;- function(combined){ # calculate the quantile range count.feature.ls &lt;- combined@meta.data[, c(&quot;nCount_RNA&quot;, &quot;nFeature_RNA&quot;)] count.feature.ls %&lt;&gt;% map(log10) %&gt;% map(~c(10^(mean(.x) + 3*sd(.x)), 10^(mean(.x) - 3*sd(.x)))) # filter cells combined &lt;- subset(combined, subset = nFeature_RNA &gt; 200 &amp; nFeature_RNA &lt; count.feature.ls[[2]][1] &amp; nCount_RNA &lt; count.feature.ls[[1]][1]) return(combined) } obj.ls %&lt;&gt;% map(filterCell) 2.3 Merge individuals combined &lt;- merge(x = obj.ls[[1]], y = obj.ls[2:4], add.cell.ids = names(dir.ls)) 2.4 Normalize, scale, find variable genes and dimension reduciton Choose the number of PC SCT combined %&lt;&gt;% SCTransform(return.only.var.genes = FALSE) %&gt;% RunPCA(features = VariableFeatures(object = .)) %&gt;% FindNeighbors(dims = 1:40) %&gt;% FindClusters(resolution = c(0.5, 0.6, 0.8, 1, 1.2, 1.5, 1.8,2,2.5,3)) %&gt;% RunUMAP(dims = 1:40) %&gt;% RunTSNE(dims = 1:40) standard process combined %&lt;&gt;% NormalizeData() %&gt;% FindVariableFeatures(selection.method = &#39;vst&#39;, nfeatures = 2000) %&gt;% ScaleData(features = rownames(.)) %&gt;% RunPCA(features = VariableFeatures(object = .)) %&gt;% FindNeighbors(dims = 1:30) %&gt;% FindClusters(resolution = c(0.5, 0.6, 0.8, 1, 1.2, 1.5, 1.8,2,2.5,3)) %&gt;% RunUMAP(dims = 1:30) %&gt;% RunTSNE(dims = 1:30) "],["find-doublet-using-scrublet.html", "Chapter 3 Find Doublet using Scrublet 3.1 description 3.2 input data 3.3 process 3.4 output", " Chapter 3 Find Doublet using Scrublet 3.1 description Scoring and identify doublet using scrublet per samples 3.2 input data filtered count matrix by cellRanger per samples 3.3 process running scrublet per samples N2-DoubletIdentify-Scurblet-Process.py -i Pre-A -r 0.02 expected doublet ratio is calculated by ~ 0.8% per 1k cell other parameters by default 3.4 output doublet scoring and identificaiton data/scrublet/*DoubletScores.csv data/scrublet/*PredictedDoublets.csv validation plots data/scrublet/pdf "],["visualize.html", "Visualize", " Visualize "],["seurat-qc-cell-level-filtering.html", "Chapter 4 Seurat QC Cell-level Filtering 4.1 Description 4.2 Load seurat object 4.3 Add other meta info 4.4 Violin plots to check", " Chapter 4 Seurat QC Cell-level Filtering 4.1 Description Basic quality control for snRNA-seq: check the distribution of number of UMIs per cell should above 500 number of genes detected per cell number of genes detected per UMI check the complexity. outlier cells might be cells have less complex RNA species like red blood cells. expected higher than 0.8 mitochondrial ratio dead or dying cells will cause large amount of mitochondrial contamination 4.2 Load seurat object combined &lt;- get(load(&#39;data/Demo_CombinedSeurat_SCT_Preprocess.RData&#39;)) 4.3 Add other meta info fraction of reads mapping to mitochondrial gene # for macaque, not all genes start with MT is mitochondrion genes mt.gene &lt;- c(&quot;MTARC2&quot;,&quot;MTFR1L&quot;,&quot;MTERF1&quot;,&quot;MTFR2&quot;,&quot;MTRF1L&quot;,&quot;MTRES1&quot;, &quot;MTO1&quot;,&quot;MTCH1&quot;,&quot;MTFMT&quot;,&quot;MTFR1&quot;,&quot;MTERF3&quot;,&quot;MTERF2&quot;,&quot;MTPAP&quot;, &quot;MTERF4&quot;,&quot;MTCH2&quot;,&#39;MTIF2&#39;,&quot;MTG2&quot;,&quot;MTIF3&quot;,&quot;MTRF1&quot;,&quot;MTCL1&quot;) combined[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(combined, features = mt.gene ) number of genes detected per UMI combined$log10GenesPerUMI &lt;- log10(combined$nFeature_RNA) / log10(combined$nCount_RNA) 4.4 Violin plots to check get the meta data df &lt;- as.data.table(combined@meta.data) sel &lt;- c(&quot;orig.ident&quot;, &quot;nCount_RNA&quot;, &quot;nFeature_RNA&quot;, &quot;percent.mt&quot;, &quot;log10GenesPerUMI&quot;) df &lt;- df[, sel, with = FALSE] df[1:3, ] ## orig.ident nCount_RNA nFeature_RNA percent.mt log10GenesPerUMI ## 1: SeuratProject 2740 1705 0.10795250 0.9400695 ## 2: SeuratProject 3140 1687 0.09593860 0.9228424 ## 3: SeuratProject 2539 1456 0.03738318 0.9290675 define plotting function fontsize &lt;- 10 linesize &lt;- 0.35 gp.ls &lt;- df[, 2:5] %&gt;% imap( ~ { # define lable fun give.n &lt;- function(x) { return(c(y = median(x) + max(x) / 10, label = round(median(x), 2))) } # assign colors col.ls &lt;- setNames( c(&#39;lightpink2&#39;, &#39;lightblue2&#39;, &#39;lightgreen&#39;, &#39;coral1&#39;), c(&quot;nCount_RNA&quot;, &quot;nFeature_RNA&quot;, &quot;percent.mt&quot;, &quot;log10GenesPerUMI&quot;) ) ggplot(data = df, aes(x = orig.ident, y = .x)) + geom_violin(trim = FALSE, fill = col.ls[.y]) + ggtitle(label = .y) + ylab(label = .y) + theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), strip.background = element_blank(), panel.border = element_blank() ) + theme( axis.text = element_text(size = fontsize), axis.line = element_line(colour = &quot;black&quot;, size = linesize), axis.ticks = element_line(size = linesize), axis.title.x = element_blank(), axis.ticks.length = unit(.05, &quot;cm&quot;), plot.title = element_text(size = fontsize + 2, hjust = 0.5), legend.position = &#39;none&#39; ) + stat_summary(fun = median, geom = &quot;point&quot;, col = &quot;black&quot;) + # Add points to plot stat_summary(fun.data = give.n, geom = &quot;text&quot;, col = &quot;black&quot;) }) grid.arrange(gp.ls[[1]], gp.ls[[2]], gp.ls[[3]], gp.ls[[4]], ncol = 2) "],["scrublet-doublet-validation.html", "Chapter 5 Scrublet Doublet Validation 5.1 Description 5.2 Load seurat object 5.3 Validate the doublet prediction 5.4 Calculate factions of doublet per cluster 5.5 Explore the component clusters for doublets by DEG 5.6 Explore the component clusters for doublets by canonical gene", " Chapter 5 Scrublet Doublet Validation 5.1 Description check the doublet prediction from scrublet by dimension reduction plot nUMI distribution judge the component for doublet cells by DEG heatmap canonical gene expression 5.2 Load seurat object combined &lt;- get(load(&#39;data/Demo_CombinedSeurat_SCT_Preprocess.RData&#39;)) Idents(combined) &lt;- &quot;cluster&quot; 5.3 Validate the doublet prediction # check whether the double cells cluster together FeaturePlot(combined, features = &quot;DoubletScores&quot;, pt.size = 0.01) DimPlot( combined, group.by = &quot;DoubletPrediction&quot;, pt.size = 0.01, cols = c(&quot;red&quot;, &quot;azure3&quot;) ) # check the nUMI for doublet and singlet VlnPlot(combined, features = &quot;nCount_RNA&quot;, pt.size = 0, group.by = &quot;DoubletPrediction&quot;) + NoLegend() 5.4 Calculate factions of doublet per cluster df &lt;- data.table(combined@meta.data) sel.meta &lt;- c(&quot;DoubletPrediction&quot;, &quot;cluster&quot;, &quot;Individual&quot;) df &lt;- df[, sel.meta, with = FALSE] df[, 2:3] %&gt;% map( ~ { freq1 &lt;- df[, .N, keyby = .(.x, DoubletPrediction)] freq1[, total := sum(N), by = .(.x)] freq1[, ratio := N / total] linesize = .35 fontsize = 8 ggplot(freq1, aes(fill=DoubletPrediction, y=ratio, x= .x)) + geom_bar(position=&quot;stack&quot;, stat=&quot;identity&quot;)+ scale_fill_manual(values = c(&quot;Doublet&quot; = &#39;red&#39;, &quot;Singlet&quot; = &quot;grey&quot;)) + xlab(&#39;Clsuter&#39;) + scale_y_continuous(breaks = seq(0,1,0.1), expand = c(0,0), name = &#39;Percentage&#39;)+ theme_bw()+ theme( panel.grid.major.x = element_blank(), panel.grid.major.y = element_blank(), panel.grid.minor = element_blank(), strip.background = element_blank(),panel.border = element_rect(size = linesize), axis.ticks = element_blank(), axis.text.x = element_text(size = 5)) }) ## $cluster ## ## $Individual 5.5 Explore the component clusters for doublets by DEG get the DEG for inferred source clusters. Here, for C33, InCGE and InMGE # find DEG cluster.markers &lt;- FindMarkers(combined, ident.1 = c(&quot;InMGE&quot;), ident.2 = &quot;InCGE&quot;, min.pct = 0.25) # subset cells of interest sel.idents &lt;- c(&quot;InMGE&quot;, &quot;InCGE&quot;, &quot;D33&quot;) combined.small &lt;- subset(combined, cells = WhichCells(combined, idents = sel.idents)) # check the expression for top DEG #sel.cells &lt;- WhichCells(combined.small, idents = sel.idents, downsample = 355) # for large dataset DoHeatmap(combined.small, features = rownames(cluster.markers)[1:40], raster = F) ## Warning in DoHeatmap(combined.small, features = rownames(cluster.markers)[1:40], : The following ## features were omitted as they were not found in the scale.data slot for the SCT assay: FNBP1 5.6 Explore the component clusters for doublets by canonical gene sel.feature &lt;- c(&quot;NXPH1&quot;, &quot;PAM&quot;, &quot;LHX6&quot;, &quot;NR2F2&quot;, &quot;ADARB2&quot;, &quot;PROX1&quot;) FeaturePlot(combined, features = sel.feature, pt.size = 0.01, ncol = 3) VlnPlot(combined.small, features = sel.feature, pt.size = 0, ncol = 3, idents = sel.idents) "],["seurat-individual-batch-effect-exploration.html", "Chapter 6 Seurat Individual Batch Effect Exploration 6.1 Descripiton 6.2 Load seurat object 6.3 Explore individual distribution by Dimplot 6.4 Calculate individual distribution per cluster with different resolution", " Chapter 6 Seurat Individual Batch Effect Exploration 6.1 Descripiton Explore the individual batch effect by Dimplot split by individual Fractions of individuals per cluster 6.2 Load seurat object combined &lt;- get(load(&#39;data/Demo_CombinedSeurat_SCT_Preprocess.RData&#39;)) 6.3 Explore individual distribution by Dimplot Idents(object = combined) &lt;- &#39;Individual&#39; DimPlot(object = combined, reduction = &quot;umap&quot;, label = T) DimPlot(object = combined, reduction = &quot;tsne&quot;, label = T) 6.4 Calculate individual distribution per cluster with different resolution df &lt;- data.table(combined@meta.data) sel.meta &lt;- c(&quot;Individual&quot;, str_c(&#39;SCT_snn_res.&#39;, c(1, 1.5, 1.8))) df &lt;- df[, sel.meta, with = FALSE] df[, 2:4] %&gt;% imap(~ { freq1 &lt;- df[, .N, keyby = .(.x, Individual)] freq1[, total := sum(N), by = .(.x)] freq1[, ratio := N / total] linesize = .35 fontsize = 8 ggplot(freq1, aes(fill = Individual, y = ratio, x = .x)) + geom_bar(position = &quot;stack&quot;, stat = &quot;identity&quot;) + scale_fill_brewer(palette = &quot;Dark2&quot;) + xlab(&#39;Clsuter&#39;) + ggtitle(.y) + scale_y_continuous(breaks = seq(0, 1, 0.1), expand = c(0, 0), name = &#39;Percentage&#39;) + theme_bw() + theme( panel.grid.major.x = element_blank(), panel.grid.major.y = element_blank(), panel.grid.minor = element_blank(), strip.background = element_blank(), panel.border = element_rect(size = linesize), axis.ticks = element_blank(), axis.text.x = element_text(size = 5) ) + coord_flip() }) ## $SCT_snn_res.1 ## ## $SCT_snn_res.1.5 ## ## $SCT_snn_res.1.8 "],["assign-gene-signature.html", "Chapter 7 Assign Gene Signature 7.1 Description 7.2 Load seurat object 7.3 Load gene lists, here using the layer-enriched genes as examples 7.4 Calcuate gene signature per gene list 7.5 Explore the gene signature by FeaturePlot and VlnPlot", " Chapter 7 Assign Gene Signature 7.1 Description Given a gene list, calculate gene signature by averaging gene expresion 7.2 Load seurat object combined &lt;- get(load(&#39;data/Demo_CombinedSeurat_SCT_Preprocess.RData&#39;)) Idents(combined) &lt;- &quot;cluster&quot; 7.3 Load gene lists, here using the layer-enriched genes as examples f.ls &lt;- list.files( &quot;data/GeneList/&quot;, pattern = &quot;FDR001.upDEG.csv$&quot;, full.names = T, recursive = T ) names(f.ls) &lt;- f.ls %&gt;% map(basename) %&gt;% map( ~ str_remove(.x, &quot;vs.*&quot;)) layer.ls &lt;- f.ls %&gt;% map( ~ { df &lt;- fread(.x) gn &lt;- df$id[!is.na(df$id)] gn &lt;- gn[which(gn %in% rownames(combined))] return(gn) }) 7.4 Calcuate gene signature per gene list mean.ls &lt;- layer.ls %&gt;% map_dfc(~ colMeans(x = as.matrix(combined@assays$SCT[.x, ]), na.rm = TRUE)) rownames(mean.ls) &lt;- rownames(combined@meta.data) ## Warning: Setting row names on a tibble is deprecated. combined &lt;- AddMetaData(combined, mean.ls, col.name = colnames(mean.ls)) 7.5 Explore the gene signature by FeaturePlot and VlnPlot names(layer.ls) %&gt;% map(~ FeaturePlot(object = combined, features = .x, pt.size = 0.001)) ## [[1]] ## ## [[2]] ## ## [[3]] ## ## [[4]] ## ## [[5]] ## ## [[6]] ## ## [[7]] ## ## [[8]] names(layer.ls) %&gt;% map(~ { VlnPlot(object = combined, features = .x, pt.size = 0) + NoLegend() }) ## [[1]] ## ## [[2]] ## ## [[3]] ## ## [[4]] ## ## [[5]] ## ## [[6]] ## ## [[7]] ## ## [[8]] "],["stacked-vlnplot-for-given-features-sets.html", "Chapter 8 Stacked Vlnplot for Given Features Sets 8.1 Descripiton 8.2 Load seurat object 8.3 Source stacked vlnplot funciton 8.4 Stacked Vlnplot given gene set", " Chapter 8 Stacked Vlnplot for Given Features Sets 8.1 Descripiton Stacked vlnplot for given gene set. Seurat V4 has provided the similar function 8.2 Load seurat object combined &lt;- get(load(&#39;data/Demo_CombinedSeurat_SCT_Preprocess.RData&#39;)) 8.3 Source stacked vlnplot funciton source(&quot;scripts/visualize/Stacked-Vlnplot.R&quot;) 8.4 Stacked Vlnplot given gene set sel.gene &lt;- c(&quot;PAX6&quot;, &quot;RBFOX1&quot;, &quot;GAD1&quot;) StackedVlnPlot(combined, sel.gene, pt.size = 0) ## Scale for &#39;y&#39; is already present. Adding another scale for &#39;y&#39;, which will replace the ## existing scale. ## Scale for &#39;y&#39; is already present. Adding another scale for &#39;y&#39;, which will replace the ## existing scale. ## Scale for &#39;y&#39; is already present. Adding another scale for &#39;y&#39;, which will replace the ## existing scale. "]]
